# Name: Benjamin Shiao
# Date: 4/7/20
# Title: Lab2 â€“ Programming in C and use of Systems Calls
# Description: this lab was to develop sample C program with two or more processes using fork( ), exit( ), wait( ), and exec( ) system calls, in addition to demonstrating the use of light weight processes.


Step 1: I noticed the code was for a .c file, so I saved the code into a file named lab2.c
Step2: I type gcc lab2.c - o executablename, and it creates the executablename file in the folder. I created a copy of my lab2.c file.
Step 3:When I run ./executeablename, I get segmentation fault. When I run ./executeablename 0, it prints Child process <number> Parent Process <number> to 99. Sometimes multiple child processes would be next to each other without a parent class inbetween, suggesting that the processes weren't always exactly in order and were slightly random
Step 4: By typing in ./executeablename <number>, the time between each process number printing grows as the number increases and the speed decreases as the number decreases. Delays of 500 is almost instant, and delays of 5000 is much slower than 500, but still fairly quick.
Step 5: I created a c file that would print a statement at its end. By running this code:
          pid1 = fork();
         pid2 = fork();
         if(!pid1){ pid3 = fork(); }
         if(!pid1 && !pid2 && pid3){ fork(); }
        I was able to get an unbalanced tree where each parent had 2 or zero childeren, satisfying the requirements. Sometimes I got a parent id of 1, suggesting a child was running after the parent exits, orphaning the child. I fixed this by adding a wait(NULL) before the end of main.
   
Step 6:
